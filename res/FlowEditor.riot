<FlowEditor>
	<div class="downarrow" data-insertat="0" onclick={ onAddStepClick }></div>
	<div each={ (step, index) in state.steps } key={ step.key }>
		<div class="step">
			<template if={ step.discriminator === 'FlowConditional' }>
				<i class="ms-Icon ms-Icon--HighlightMappedShapes"></i>
				<span>{ __(step.loop ? 'Loop while' : 'If') }</span>
				<div class="btngrp">
					<button onclick={ onEditFlowConditional } data-flow={ index }>{ __('Edit') }</button>
					<button onclick={ onDeleteStep } data-flow={ index }><i class="ms-Icon ms-Icon--RecycleBin"></i></button>
				</div>
			</template>
			<template if={ step.discriminator === 'FlowMath' }>
				<i class="ms-Icon ms-Icon--CalculatorEqualTo"></i>
				<span><span if={step.resultinto.length > 0}>{ step.resultinto } = </span>{ step.expression.replace(/\n/g,'‚Æê') }</span>
				<div class="btngrp">
					<button onclick={ onEditFlowMath } data-flow={ index }>{ __('Edit') }</button>
					<button onclick={ onDeleteStep } data-flow={ index }><i class="ms-Icon ms-Icon--RecycleBin"></i></button>
				</div>
			</template>
			<template if={ step.discriminator === 'FlowAction' }>
				<i class="ms-Icon ms-Icon--Processing"></i>
				<span><span if={step.resultinto.length > 0}>{ step.resultinto } = </span>{ __actionByChannel(step.channel) }</span>
				<div class="btngrp">
					<button onclick={ onEditFlowAction } data-flow={ index }>{ __('Edit') }</button>
					<button onclick={ onDeleteStep } data-flow={ index }><i class="ms-Icon ms-Icon--RecycleBin"></i></button>
				</div>
			</template>
			<template if={ step.discriminator === 'FlowVariable' }>
				<i class="ms-Icon ms-Icon--Variable"></i>
				<span>{ step.variable } = { __(step.type) }</span>
				<div class="btngrp">
					<button onclick={ onEditFlowVariable } data-flow={ index }>{ __('Edit') }</button>
					<button onclick={ onDeleteStep } data-flow={ index }><i class="ms-Icon ms-Icon--RecycleBin"></i></button>
				</div>
			</template>
			<template if={ step.discriminator === 'FlowWait' }>
				<i class="ms-Icon ms-Icon--Clock"></i>
				<span>{ __('Waiting for {{seconds}} seconds', { seconds: (step.time/1000) }) }</span>
				<div class="btngrp">
					<button onclick={ onEditFlowWait } data-flow={ index }>{ __('Edit') }</button>
					<button onclick={ onDeleteStep } data-flow={ index }><i class="ms-Icon ms-Icon--RecycleBin"></i></button>
				</div>
			</template>
			<template if={ step.discriminator === 'FlowWebRequest' }>
				<i class="ms-Icon ms-Icon--Globe"></i>
				<span>{ step.method + ' ' + step.url }</span>
				<div class="btngrp">
					<button onclick={ onEditFlowWebRequest } data-flow={ index }>{ __('Edit') }</button>
					<button onclick={ onDeleteStep } data-flow={ index }><i class="ms-Icon ms-Icon--RecycleBin"></i></button>
				</div>
			</template>
		</div>
		<template if={ step.discriminator === 'FlowConditional' }>
			<div class="subflow">
				<floweditor flow={ step.flow }></floweditor>
			</div>
			<template if={ !step.loop }>
				<div class="step else"><span>{ __('Else') }</span></div>
				<div class="subflow">
					<floweditor flow={ step.elseflow }></floweditor>
				</div>
			</template>
			<div class="step else" if={ !step.loop }><span>{ __('End if') }</span></div>
			<div class="step else" if={ step.loop }><span>{ __('End loop') }</span></div>
		</template>
		<div class="downarrow" data-insertat={ index+1 } onclick={ onAddStepClick }></div>
	</div>

	<style>
		:host {
			display: block;
		}

		:host .step {
			width: calc(100% - 22px);
		}

		:host .downarrow:hover {
			cursor: pointer;
			background: none;
			text-align: center;
			font-size: 2em;
			line-height: 35px;
		}
		:host .downarrow:hover:before {
			content: "+";
		}

		:host .subflow {
			width: 90%;
			margin-left: 10%;
		}
		:host .step.else {
			width: calc(95% - 22px);
			margin-left: 5%;
			opacity: 0.8;
		}
	</style>
	<script>
		const { ipcRenderer } = require('electron');
		const riot = require('riot');
		const ConditionalGroup = require('../lib/ConditionalGroup').default;
		import FlowVariableEditor from './FlowVariableEditor.riot';
		const FlowVariableEditorMount = riot.component(FlowVariableEditor);
		import WebRequestInput from './WebRequestInput.riot';
		const WebRequestInputMount = riot.component(WebRequestInput);


		export default {

			__actionByChannel(channel) {
				let actions = TTVST.Broadcast.getAction({ channel });
				if(actions.length > 0) {
					return this.__(actions[0].addon) + ': ' + this.__(actions[0].label);
				} else {
					return channel;
				}
			},

			onBeforeMount(props, state) {
				this.__ = global.TTVST.i18n.__;
				this.state.steps = [];
				this.state.keystate = 0;
				this.state.editingIndex = -1;

				if(typeof(props.flow) === 'object' && Array.isArray(props.flow)) {
					for(let i = 0; i < props.flow.length; i++) {
						this.state.keystate++;
						props.flow[i].k = this.state.keystate;
					}
					this.state.steps = props.flow;
				}
			},

			async onAddStepClick(e) {
				const self = this;

				let btn = e.currentTarget;
				let insertAt = parseInt(btn.dataset.insertat);
	
				let selectedStep = await new Promise((resolve, reject) => {
					let typlbl = document.createElement('label');
					let typinp = document.createElement('select');
					let options = [document.createElement('option'),document.createElement('option'),document.createElement('option'),document.createElement('option'),document.createElement('option'),document.createElement('option')];
					options[0].value = 'FlowConditional';options[1].value = 'FlowMath';options[2].value = 'FlowAction';options[3].value = 'FlowVariable';options[4].value = 'FlowWait';options[5].value = 'FlowWebRequest';
					options[0].appendChild(document.createTextNode(self.__('Condition / Loop')));
					options[1].appendChild(document.createTextNode(self.__('Math')));
					options[2].appendChild(document.createTextNode(self.__('Action')));
					options[3].appendChild(document.createTextNode(self.__('Variable')));
					options[4].appendChild(document.createTextNode(self.__('Wait')));
					options[5].appendChild(document.createTextNode(self.__('Make a web request')));
					for(let i = 0; i < options.length; i++)
						typinp.appendChild(options[i]);
					
					let typdesc = document.createElement('small');
					typdesc.innerText = self.__('Select a step to insert');
					typlbl.appendChild(typinp);
					typlbl.appendChild(typdesc);

					let response = false;
					let nfmodal = TTVST.ui.modal([typlbl], self.__('Add step'), 'FabricNewFolder', () => {
						if(response) {
							resolve(nfmodal.$('select > option:checked').value);
						} else {
							resolve('');
						}
					}, [
						{ key: 'ok', title: 'OK', callback: () => { response = true; } },
						{ key: 'cancel', title: 'Cancel' }
					], true);
				});
				if(selectedStep.length > 0) {
					switch(selectedStep) {
						case 'FlowConditional':
							this.state.keystate++;
							this.state.steps.splice(insertAt, 0, { k: this.state.keystate, discriminator: 'FlowConditional', conditional: '{"discriminator":"ConditionGroup","conditions":[],"operator":"and"}', flow: [], elseflow: [], loop: false });
							break;
						case 'FlowMath':
							this.state.keystate++;
							this.state.steps.splice(insertAt, 0, { k: this.state.keystate,discriminator: 'FlowMath', expression: '', resultinto: '' });
							break;
						case 'FlowAction':
							this.state.keystate++;
							this.state.steps.splice(insertAt, 0, { k: this.state.keystate,discriminator: 'FlowAction', channel: '', parameters: [], resultinto: '' });
							break;
						case 'FlowVariable':
							this.state.keystate++;
							this.state.steps.splice(insertAt, 0, { k: this.state.keystate, discriminator: 'FlowVariable', variable: '', type: 'number', content: 0, processing: 'none', processingextra: '' });
							break;
						case 'FlowWait':
							this.state.keystate++;
							this.state.steps.splice(insertAt, 0, { k: this.state.keystate, discriminator: 'FlowWait', time: 5000 });
							break;
						case 'FlowWebRequest':
							this.state.keystate++;
							this.state.steps.splice(insertAt, 0, { k: this.state.keystate, discriminator: 'FlowWebRequest', url: '', method: 'GET', contentType: 'application/json', headers: '', body: '', whattoresult: 'body', resultinto: '' });
							break;
					}
					this.update();
				}
			},

			async onDeleteStep(e) {
				let btn = e.currentTarget;
				let flowIndex = parseInt(btn.dataset.flow);
				this.state.steps.splice(flowIndex, 1);
				this.update();
			},

			async onEditFlowMath(e) {
				let btn = e.currentTarget;
				let flowIndex = parseInt(btn.dataset.flow);
				let math = this.state.steps[flowIndex]
				
				if(math.discriminator != 'FlowMath') {
					return;
				}

				this.state.editingIndex = flowIndex;

				const self = this;
				let [resultinto, expression] = await new Promise((resolve, reject) => {
					let expressionlbl = document.createElement('label');
					let expressioninp = document.createElement('textarea');
					let expressiondesc = document.createElement('small');
					let resultintolbl = document.createElement('label');
					let resultintoinp = document.createElement('input');
					let resultintodesc = document.createElement('small');

					expressioninp.setAttribute('id', 'flowmathedit_expression');
					expressioninp.innerHTML = math.expression.replace(/</g,'&lt;').replace(/>/g,'&gt;');
					expressionlbl.innerText = self.__('Math.js expression');
					expressionlbl.appendChild(expressioninp);
					expressiondesc.innerText = self.__('Enter your Math.js expression here. Learn more about the syntax on mathjs.org. You can use TTVST variables to input data.');
					expressionlbl.appendChild(expressioninp);
					expressionlbl.appendChild(expressiondesc);

					resultintoinp.setAttribute('id', 'flowmathedit_resultinto');
					resultintoinp.setAttribute('type', 'text');
					resultintoinp.value = math.resultinto;
					resultintolbl.innerText = self.__('Result into variable');
					resultintolbl.appendChild(resultintoinp);
					resultintodesc.innerText = self.__('Enter a TTVST variable that you want the result put into');
					resultintolbl.appendChild(resultintoinp);
					resultintolbl.appendChild(resultintodesc);

					let response = false;
					let nfmodal = TTVST.ui.modal([expressionlbl, resultintolbl], self.__('Edit Math'), 'CalculatorEqualTo', () => {
						if(response) {
							let resultinto = nfmodal.$('#flowmathedit_resultinto').value;
							if(resultinto.length > 0) {
								let match = resultinto.match(/([a-z][a-z0-9]+)/i);
								if(match) {
									resultinto = match[1];
								} else {
									TTVST.ui.alert('Variable name is invalid');
									return false;
								}
							}
							resolve([resultinto, nfmodal.$('#flowmathedit_expression').value]);
						} else {
							resolve([null, null]);
						}
					}, [
						{ key: 'ok', title: 'OK', callback: () => { response = true; } },
						{ key: 'cancel', title: 'Cancel' }
					], true);
				});
				if(resultinto !== null) {
					this.state.steps[flowIndex].expression = expression;
					this.state.steps[flowIndex].resultinto = resultinto;
					this.update();
				}
				this.state.editingIndex = -1;
			},

			async onEditFlowAction(e) {
				let btn = e.currentTarget;
				let flowIndex = parseInt(btn.dataset.flow);
				let action = this.state.steps[flowIndex]
				
				if(action.discriminator != 'FlowAction') {
					return;
				}

				this.state.editingIndex = flowIndex;

				const self = this;
				let [resultinto, channel, parameters] = await new Promise((resolve, reject) => {
					let selectactionlbl = document.createElement('label');
					let selectactiontxt = document.createTextNode(self.__('No action selected'));
					let selectactioninp = document.createElement('button');
					let resultintolbl = document.createElement('label');
					let resultintoinp = document.createElement('input');
					let resultintodesc = document.createElement('small');

					selectactioninp.setAttribute('type', 'button');
					selectactioninp.innerText = self.__('Select Action');
					let resultchannel = action.channel, resultparameters = action.parameters;
					let resultaction = TTVST.Broadcast.getAction({ channel: resultchannel });
					if(resultaction.length > 0) selectactiontxt.nodeValue = self.__(resultaction[0].label);
					selectactioninp.onclick = async () => {
						let botWrap = document.querySelector('chatbotwrap');
						let wrapSym = botWrap[Object.getOwnPropertySymbols(botWrap)[0]];

						let dyninput = [];
						try {
							dyninput = await ipcRenderer.invoke('app.ttvst.chatbot.getContextForDynamicInput', wrapSym.getMoreContextVars());
						}catch(e) {
							console.error(e);
						}
						let r = await TTVST.ui.selectAction(resultchannel, resultparameters, dyninput);
						if(r !== null) {
							resultchannel = r.channel;
							resultparameters = r.parameter;
							
							resultaction = TTVST.Broadcast.getAction({ channel: resultchannel });
							if(resultaction.length > 0) selectactiontxt.nodeValue = self.__(resultaction[0].label);
						}
					};
					selectactionlbl.appendChild(selectactiontxt);
					selectactionlbl.appendChild(document.createElement('br'));
					selectactionlbl.appendChild(selectactioninp);

					resultintoinp.setAttribute('id', 'flowactionedit_resultinto');
					resultintoinp.setAttribute('type', 'text');
					resultintoinp.value = action.resultinto;
					resultintolbl.innerText = self.__('Result into variable');
					resultintolbl.appendChild(resultintoinp);
					resultintodesc.innerText = self.__('Enter a TTVST variable that you want the result put into');
					resultintolbl.appendChild(resultintoinp);
					resultintolbl.appendChild(resultintodesc);

					let response = false;
					let nfmodal = TTVST.ui.modal([selectactionlbl, resultintolbl], self.__('Edit Action'), 'Processing', () => {
						if(response) {
							let resultinto = nfmodal.$('#flowactionedit_resultinto').value;
							if(resultinto.length > 0) {
								let match = resultinto.match(/([a-z][a-z0-9]+)/i);
								if(match) {
									resultinto = match[1];
								} else {
									TTVST.ui.alert('Variable name is invalid');
									return false;
								}
							}
							resolve([resultinto, resultchannel, resultparameters]);
						} else {
							resolve([null, null, null]);
						}
					}, [
						{ key: 'ok', title: 'OK', callback: () => { response = true; } },
						{ key: 'cancel', title: 'Cancel' }
					], true);
				});
				if(resultinto !== null) {
					this.state.steps[flowIndex].channel = channel;
					this.state.steps[flowIndex].parameters = parameters;
					this.state.steps[flowIndex].resultinto = resultinto;
					this.update();
				}
				this.state.editingIndex = -1;
			},

			async onEditFlowVariable(e) {
				let btn = e.currentTarget;
				let flowIndex = parseInt(btn.dataset.flow);
				let variable = this.state.steps[flowIndex]
				
				if(variable.discriminator != 'FlowVariable') {
					return;
				}

				this.state.editingIndex = flowIndex;

				const self = this;
				let result = await new Promise((resolve, reject) => {
					let fve = document.createElement('flowvariableeditor');
					let fveSym = FlowVariableEditorMount(fve, variable);

					let response = false;
					let nfmodal = TTVST.ui.modal([fve], self.__('Edit Variable'), 'Variable', () => {
						if(response) {
							let iflowvar = fveSym.getIFlowVariable();
							if(iflowvar.variable.match(/^[a-z]([a-z0-9]+)?$/i)) {
								resolve(iflowvar);
							} else {
								TTVST.ui.alert('Variable name is invalid. Must start with a letter and can only consist of numbers and letters.');
								return false;
							}
						} else {
							resolve(null);
						}
					}, [
						{ key: 'ok', title: 'OK', callback: () => { response = true; } },
						{ key: 'cancel', title: 'Cancel' }
					], true);
				});
				if(result !== null) {
					Object.assign(this.state.steps[flowIndex], result);
					this.update();
				}
				this.state.editingIndex = -1;
			},

			async onEditFlowConditional(e) {
				let btn = e.currentTarget;
				let flowIndex = parseInt(btn.dataset.flow);
				let conditional = this.state.steps[flowIndex]
				
				if(conditional.discriminator != 'FlowConditional') {
					return;
				}

				this.state.editingIndex = flowIndex;

				const self = this;
				let result = await new Promise((resolve, reject) => {
					let fce = document.createElement('conditionalgroupinput');
					riot.mount(fce, { condgroup: new ConditionalGroup(JSON.parse(conditional.conditional)) });
					let fceSym = fce[Object.getOwnPropertySymbols(fce)[0]];
					let looplbl = document.createElement('label');
					let loopinp = document.createElement('input');
					let loopdesc = document.createElement('small');
					looplbl.innerText = self.__('Loop');
					loopinp.setAttribute('type', 'checkbox');
					if(conditional.loop) {
						loopinp.setAttribute('checked', 'checked');
					}
					looplbl.appendChild(loopinp);
					loopdesc.innerText = self.__('Check this box to loop the subflow as long as the condition is met');
					looplbl.appendChild(loopdesc);

					let response = false;
					let nfmodal = TTVST.ui.modal([fce, looplbl], self.__('Edit Conditional'), 'HighlightMappedShapes', () => {
						if(response) {
							resolve([fceSym.condgroup, loopinp.checked]);
						} else {
							resolve(null);
						}
					}, [
						{ key: 'ok', title: 'OK', callback: () => { response = true; } },
						{ key: 'cancel', title: 'Cancel' }
					], true);
				});
				if(result !== null) {
					this.state.steps[flowIndex].conditional = result[0].toString();
					this.state.steps[flowIndex].loop = result[1];
					this.update();
				}
				this.state.editingIndex = -1;
			},
			
			async onEditFlowWait(e) {
				let btn = e.currentTarget;
				let flowIndex = parseInt(btn.dataset.flow);
				let wait = this.state.steps[flowIndex]
				
				if(wait.discriminator != 'FlowWait') {
					return;
				}

				this.state.editingIndex = flowIndex;

				const self = this;
				let waittime = await new Promise((resolve, reject) => {
					let waittimelbl = document.createElement('label');
					let waittimeinp = document.createElement('input');
					let waittimedesc = document.createElement('small');

					waittimeinp.setAttribute('id', 'flowwaitedit_time');
					waittimeinp.setAttribute('type', 'number');
					waittimeinp.value = wait.time/1000;
					waittimelbl.innerText = self.__('Time to wait in seconds');
					waittimelbl.appendChild(waittimeinp);
					waittimedesc.innerText = self.__('How long the execution is paused before continuing');
					waittimelbl.appendChild(waittimeinp);
					waittimelbl.appendChild(waittimedesc);

					let response = false;
					let nfmodal = TTVST.ui.modal([waittimelbl], self.__('Edit Wait'), 'Clock', () => {
						if(response) {
							let waittime = parseFloat(nfmodal.$('#flowwaitedit_time').value);
							if(isNaN(waittime)) {
								waittime = 0;
							}
							resolve(Math.round(waittime * 1000));
						} else {
							resolve(null);
						}
					}, [
						{ key: 'ok', title: 'OK', callback: () => { response = true; } },
						{ key: 'cancel', title: 'Cancel' }
					], true);
				});
				if(waittime !== null) {
					this.state.steps[flowIndex].time = waittime;
					this.update();
				}
				this.state.editingIndex = -1;
			},
			
			async onEditFlowWebRequest(e) {
				let btn = e.currentTarget;
				let flowIndex = parseInt(btn.dataset.flow);
				let webrequest = this.state.steps[flowIndex]
				
				if(webrequest.discriminator != 'FlowWebRequest') {
					return;
				}

				this.state.editingIndex = flowIndex;

				const self = this;
				let result = await new Promise(async (resolve, reject) => {
					let botWrap = document.querySelector('chatbotwrap');
					let wrapSym = botWrap[Object.getOwnPropertySymbols(botWrap)[0]];
					let dyninput = [];
					try {
						dyninput = await ipcRenderer.invoke('app.ttvst.chatbot.getContextForDynamicInput', wrapSym.getMoreContextVars());
					} catch(e) {
						console.error(e);
					}

					let fve = document.createElement('webrequestinput');
					let fveSym = WebRequestInputMount(fve, { step: webrequest, dyninput });

					let response = false;
					let nfmodal = TTVST.ui.modal([fve], self.__('Edit Web Request'), 'Globe', () => {
						if(response) {
							let flowobj = fveSym.getFlowObject();
							if(flowobj.resultinto.length > 0) {
								let match = flowobj.resultinto.match(/([a-z][a-z0-9]+)/i);
								if(!match) {
									TTVST.ui.alert('Variable name is invalid');
									return false;
								}
							}
							resolve(flowobj);
						} else {
							resolve(null);
						}
					}, [
						{ key: 'ok', title: 'OK', callback: () => { response = true; } },
						{ key: 'cancel', title: 'Cancel' }
					], true);
				});
				if(result !== null) {
					Object.assign(this.state.steps[flowIndex], result);
					this.update();
				}
				this.state.editingIndex = -1;
			}
		}
	</script>

</FlowEditor>